{"version":3,"sources":["src/bodies/ball.js","src/bodies/brick.js","src/bodies/paddle.js","src/bodies/score.js","src/constants.js","src/initialize.js","src/utils.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhDA;AAAA;CCAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApHA;AAAA;CCAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3CA;AAAA;CCAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5CA;AAAA;CCAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAAA;CCAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnJA;AAAA;CCAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5EA;AAAA","file":"../breakout-backend/web/app.js","sourcesContent":["/**\n * @module bodies/ball\n */\n\nconst constants = require('../constants')\nconst utils = require('../utils')\n\n/**\n * Represents the ball\n * @constructor\n * @prop {int} x - horizontal position\n * @prop {int} y - vertical position\n * @prop {int} dx - horizontal speed\n * @prop {int} dy - vertical speed\n */\nexports.Ball = function Ball () {\n  this.x = constants.C_WIDTH / 2\n  this.y = constants.C_HEIGHT - 80\n\n  this.dx = utils.randomInRange(4, 6) * utils.randomSign()\n  this.dy = -8\n\n  this.radius = 10\n  this.color = 'white'\n\n  /**\n   * Move the ball to new position\n   * @method\n   * @param {int} dx\n   * @param {int} dy\n   */\n  this.move = function (dx, dy) {\n    this.dx = dx\n    this.dy = dy\n\n    this.x += dx\n    this.y += dy\n  }\n\n  /**\n   * Draw the ball on the provides 2D context\n   * @method\n   */\n  this.draw = function () {\n    fill(this.color)\n    ellipse(this.x, this.y, this.radius * 2)\n  }\n}\n","/**\n * @module bodies/brick\n */\n\nconst constants = require('../constants')\nconst utils = require('../utils')\n\n/**\n * Represents a brick\n * @constructor\n * @prop {number} x - horizontal position\n * @prop {number} height\n * @prop {number} width\n * @prop {number[]} color\n */\nfunction Brick (x, height, width) {\n  this.x = x\n  this.y = 0\n  this.height = height\n  this.width = width\n  this.color = utils.randomColor()\n\n  /**\n   * Move the ball to new position\n   * @method\n   * @param {int} dx\n   * @param {int} dy\n   */\n  this.move = function (dx, dy) {\n    this.x += dx\n    this.y += dy\n  }\n\n  /**\n   * Draw the brick on the screen\n   * @method\n   */\n  this.draw = function () {\n    fill.apply(fill, this.color)\n    rect(this.x, this.y, this.width, this.height)\n  }\n}\nexports.Brick = Brick\n\n/**\n * Represents a row of bricks\n * @constructor\n * @param {number} rowIndex - The index of row\n * @prop {Brick[]} bricks\n */\nfunction BrickRow (rowIndex = 0) {\n  const count = 8\n  const margin = 10\n  const height = 30\n  const width = (constants.C_WIDTH - count * margin) / count\n\n  // Create new row\n  this.bricks = new Array(count)\n    .fill(null)\n    .map((_, i) => new Brick((width + margin) * i, height, width))\n\n  /**\n   * Move the bricks in this row down 1 row\n   * @method\n   */\n  this.moveDown = function () {\n    for (const brick of this.bricks) {\n      brick.move(0, height + margin)\n    }\n  }\n\n  /**\n   * Checks if the ball colides with a brick in the row\n   * @method\n   * @param {Ball} ball\n   * @return {Ball}\n   */\n  this.isBallCollision = function (ball) {\n    for (const brick of this.bricks) {\n      if (utils.isBallCollision(ball, brick)) {\n        return brick\n      }\n    }\n    return null\n  }\n\n  /**\n   * Removes brick from the row\n   * @method\n   * @param {Brick} brick\n   */\n  this.removeBrick = function (brick) {\n    this.bricks = this.bricks.filter((b) => b !== brick)\n  }\n\n  /**\n   * Checks if the row is empty\n   * @method\n   * @return {bool}\n   */\n  this.isEmpty = function () {\n    return this.bricks.length < 1\n  }\n\n  /**\n   * Draws the bricks\n   * @method\n   */\n  this.draw = function () {\n    for (const brick of this.bricks) {\n      brick.draw()\n    }\n  }\n}\n\nexports.BrickRow = BrickRow\n","/**\n * @module bodies/paddle\n */\n\nconst constants = require('../constants')\nconst utils = require('../utils')\n\n/**\n * Represents paddle\n * @class\n * @prop {number} height\n * @prop {number} width\n * @prop {number} borderRadius\n * @prop {number} x\n * @prop {number} y\n * @prop {string} color\n */\nexports.Paddle = function Paddle () {\n  this.height = 30\n  this.width = 120\n  this.borderRadius = 4\n\n  this.x = (constants.C_WIDTH - this.width) / 2\n  this.y = constants.C_HEIGHT - this.height - 10\n\n  this.color = 'white'\n\n  /**\n   * Move the paddle horizontally\n   * @param {number} dx - Relative change in x\n   */\n  this.move = function (dx) {\n    this.x += dx\n  }\n\n  /**\n   * Daw the paddle on the screen\n   */\n  this.draw = function () {\n    fill(this.color)\n    rect(this.x, this.y, this.width, this.height, this.borderRadius)\n  }\n}\n","/**\n * @module bodies/score\n */\n\nconst constants = require('../constants')\nconst utils = require('../utils')\n\n/**\n * Represents the user score\n * @class\n * @prop {number} score\n * @prop {string} color\n */\nexports.Score = function Score () {\n  let score = 0\n  const color = 'white'\n\n  /**\n   * Increases the score by 1\n   * @method\n   */\n  this.add = function () {\n    score += 1\n  }\n\n  /**\n   * Get the current score\n   * @method\n   * @return {number}\n   */\n  this.get = function () {\n    return score\n  }\n\n  /**\n   * Draws the score on the screen\n   * @method\n   */\n  this.draw = function () {\n    fill(color)\n    textFont('Arial', 30)\n    text(score, constants.C_WIDTH / 2, constants.C_HEIGHT / 2)\n  }\n}\n","/**\n * @module constants\n */\n\n/**\n * Canvas height\n * @type {number}\n */\nexports.C_HEIGHT = 600\n/**\n * Canvas width\n * @type {number}\n */\nexports.C_WIDTH = 800\n","/**\n * @module initialize\n */\n\nconst P5 = require('p5')\n\nconst constants = require('./constants')\nconst utils = require('./utils')\n\nconst { Ball } = require('./bodies/ball')\nconst { Paddle } = require('./bodies/paddle')\nconst { BrickRow } = require('./bodies/brick')\nconst { Score } = require('./bodies/score')\n\nconst state = {}\n\nfunction addBrickRow () {\n  // Move other rows down\n  for (const row of state.brickRows) {\n    row.moveDown()\n  }\n\n  // Create new row\n  const rowIndex = state.brickRows.length\n  const row = new BrickRow(rowIndex)\n\n  // Place in on top\n  state.brickRows.unshift(row)\n}\n\nfunction removeBrickFromRow (brickRow, brick) {\n  brickRow.removeBrick(brick)\n\n  // Check if bottom row is empty\n  const lastIndex = state.brickRows.length - 1\n  const isBottomRow = brickRow == state.brickRows[lastIndex]\n\n  if (isBottomRow && brickRow.isEmpty()) {\n    state.brickRows.pop()\n  }\n}\n\nconst p5 = new P5(function (sketch) {\n\n  // Set globals\n  window.fill = sketch.fill.bind(sketch)\n  window.background = sketch.background.bind(sketch)\n  window.rect = sketch.rect.bind(sketch)\n  window.ellipse = sketch.ellipse.bind(sketch)\n  window.textFont = sketch.textFont.bind(sketch)\n  window.text = sketch.text.bind(sketch)\n\n  sketch.setup = function () {\n    sketch.createCanvas(constants.C_WIDTH, constants.C_HEIGHT)\n\n    // Initialise paddle\n    state.paddle = new Paddle()\n    state.paddleCollisions = 0\n\n    // Initialise ball\n    state.ball = new Ball()\n\n    // Initialise bricks\n    state.brickRows = []\n    addBrickRow()\n    addBrickRow()\n\n    // Initialise score\n    state.score = new Score()\n  }\n\n  sketch.draw = function () {\n    // Clear canvas\n    background(0)\n    fill(255)\n\n    // Paddle movement\n    if (state.paddle) {\n      const { x, y, width } = state.paddle\n\n      if (sketch.keyIsPressed && sketch.keyCode == sketch.LEFT_ARROW && x > 0) {\n        state.paddle.move(-8)\n      }\n      if (sketch.keyIsPressed && sketch.keyCode == sketch.RIGHT_ARROW && x < constants.C_WIDTH - width) {\n        state.paddle.move(8)\n      }\n\n      state.paddle.draw()\n    }\n\n    // Ball movement\n    if (state.ball) {\n      let { x, y, dx, dy, radius } = state.ball\n\n      // Wall collission\n      if (x + dx > constants.C_WIDTH - radius || x + dx < radius) {\n        dx = -dx\n\n        // Ceiling collission\n      } else if (y + dy < radius) {\n        dy = -dy\n\n        // Floor collission\n      } else if (y + dy > constants.C_HEIGHT - radius) {\n        console.log('GAME OVER')\n        setup()\n        return\n\n        // Paddle collision\n      } else if (utils.isBallCollision(state.ball, state.paddle)) {\n        dy = -dy\n        state.paddleCollisions += 1\n        if (state.paddleCollisions > 4) {\n          addBrickRow()\n          state.paddleCollisions = 0\n        }\n\n        // Brick collision\n      } else {\n        // Reverse loop over the brickRows -> bottom rows will be first checked\n        for (let i = state.brickRows.length - 1; i >= 0; i--) {\n          const brickRow = state.brickRows[i]\n          const brick = brickRow.isBallCollision(state.ball)\n\n          if (brick) {\n            removeBrickFromRow(brickRow, brick)\n\n            state.score.add()\n            dy = -dy\n            break\n          }\n        }\n      }\n\n      state.ball.move(dx, dy)\n      state.ball.draw()\n    }\n\n    for (const brickRow of state.brickRows) {\n      brickRow.draw()\n    }\n\n    state.score.draw()\n  }\n})\n\n\n","/**\n * @module utils\n */\n\n\n/**\n * Calculate distance between 2 points\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @return {number}\n */\nfunction calcPointsDistance(x1, y1, x2, y2) {\n  let xDist = x2 - x1\n  let yDist = y2 - y1\n\n  // Pythagoras\n  return Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2))\n}\nexports.calcPointsDistance = calcPointsDistance\n\n/**\n * Check if value is between min and max\n * @param {number} val\n * @param {number} min\n * @param {number} max\n * @return {boolean}\n */\nfunction inRange(val, min, max) {\n  return val >= Math.min(min, max) && val <= Math.max(min, max)\n}\nexports.inRange = inRange\n\n/**\n * Check if there is a collision between ball and brick\n * @param {Ball} ball\n * @param {Brick} brick\n * @return {boolean}\n */\nfunction isBallCollision(ball, brick) {\n  return inRange(ball.x, brick.x - ball.radius, brick.x + brick.width + ball.radius) &&\n    inRange(ball.y, brick.y - ball.radius, brick.y + brick.height + ball.radius)\n}\nexports.isBallCollision = isBallCollision\n\n/**\n * Generate random number between min and max\n * @param {number} min\n * @param {number} max\n * @return {number}\n */\nfunction randomInRange(min, max) {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.round(Math.random() * (max - min)) + min\n}\nexports.randomInRange = randomInRange\n\n/**\n * Generate either 1 or -1\n * @return {number}\n */\nfunction randomSign() {\n  return Math.round(Math.random()) ? 1 : -1\n}\nexports.randomSign = randomSign\n\n/**\n * Generate random color in RGB\n * @return {number[]}\n */\nfunction randomColor() {\n  return [0, 0, 0].map(() => randomInRange(50, 255))\n}\nexports.randomColor = randomColor\n"]}